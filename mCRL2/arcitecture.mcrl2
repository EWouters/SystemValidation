sort
	Chamber = struct cI | cO | cL | cH;
	Pressure = struct pA | pL | pH;
	Door = struct dAI | dAO | dLI | dLO | dH;
	Robot = struct rI | rO | rT;
	State = struct sO | sC;
	Action = struct aG | aR;

map
	r2d: Chamber # Robot -> Door;
	sp: List(Pressure) # Chamber # Pressure -> List(Pressure);
	gp: List(Pressure) # Chamber -> Pressure;
	sd: List(State) # Door # State -> List(State);
	gd: List(State) # Door -> State;
	sr: List(Action) # Robot # Action -> List(Action);
	gr: List(Action) # Robot -> Action;
	
	% get list of doors connected to chamber
	c2d: Chamber -> List(Door);
	
	can_door_open: Door # List(Pressure) -> Bool;
	is_chamber_sealed: Chamber # List(State) -> Bool;
var
	pressures: List(Pressure);
	pressure: Pressure;
	actions: List(Action);
	action: Action;
	states: List(State);
	state: State;

eqn
	r2d(cI, rI) = dAI;
	r2d(cI, rO) = dAI;
	r2d(cO, rI) = dAO;
	r2d(cO, rO) = dAO;
	r2d(cL, rI) = dLI;
	r2d(cL, rO) = dLO;
	r2d(cH, rI) = dH;
	r2d(cH, rO) = dH;
	
	% Dictionary for Chamber to list of Pressures
	sp(pressures, cI, pressure) = [pressure] ++ tail(pressures);
	sp(pressures, cO, pressure) = [head(pressures), pressure] ++ tail(tail(pressures));
	sp(pressures, cI, pressure) = rtail(rtail(pressures)) ++ [pressure, rhead(pressures)];
	sp(pressures, cH, pressure) = rtail(pressures) ++ [pressure];
	gp(pressures, cI) = head(pressures);
	gp(pressures, cO) = head(tail(pressures));
	gp(pressures, cI) = rhead(rtail(pressures));
	gp(pressures, cH) = rhead(pressures);
	
	% Dictionary for Door to list of States
	sd(states, dAI, state) = [state] ++ tail(states);
	sd(states, dAO, state) = [head(states), state] ++ tail(tail(states));
	sd(states, dLI, state) = rtail(rtail(rtail(states))) ++ [state] ++ tail(tail(tail(states)));
	sd(states, dLO, state) = rtail(rtail(states)) ++ [state, rhead(states)];
	sd(states, dH,  state) = rtail(states) ++ [state];
	gd(states, dAI) = head(states);
	gd(states, dAO) = head(tail(states));
	gd(states, dLI) = head(tail(tail(states)));
	gd(states, dLO) = rhead(rtail(states));
	gd(states, dH ) = rhead(states);

	% Dictionary for Robot to list of Actions
	sr(actions, rI, action) = [action] ++ tail(actions);
	sr(actions, rO, action) = [head(actions), action, rhead(actions)];
	sr(actions, rT, action) = rtail(actions) ++ [action];
	gr(actions, rI) = head(actions);
	gr(actions, rO) = head(tail(actions));
	gr(actions, rT) = rhead(actions);

	c2d(cI) = [dAI, dLI];
	c2d(cO) = [dAO, dLO];
	c2d(cL) = [dLI, dLO, dH];
	c2d(cH) = [dH];

	can_door_open(dAI, pressures) = (gp(pressures, cI) == pA);
	can_door_open(dAO, pressures) = (gp(pressures, cO) == pA);
	can_door_open(dLI, pressures) = (gp(pressures, cI) == pL) && (gp(pressures, cL) == pL);
	can_door_open(dLO, pressures) = (gp(pressures, cO) == pL) && (gp(pressures, cL) == pL);
	can_door_open(dH,  pressures) =  gp(pressures, cL) == pH;

	%is_chamber_sealed(cI, states) = (gd(states, dAI) == sC) && (gd(states, dLI) == sC);
	is_chamber_sealed(cI, states) = true;
	is_chamber_sealed(cO, states) = (gd(states, dAO) == sC) && (gd(states, dLO) == sC);
	is_chamber_sealed(cL, states) = (gd(states, dLI) == sC) && (gd(states, dLO) == sC) && (gd(states, dH ) == sC);
	is_chamber_sealed(cH, states) = (gd(states, dH ) == sC);


act
	tray_empty;
	nop;
	
	s_seal_confirmed: Chamber # List(State);
	r_seal_confirmed: Chamber # List(State);
	c_seal_confirmed: Chamber # List(State);
	
	s_seal_chamber: Chamber # List(State);
	r_seal_chamber: Chamber # List(State);
	c_seal_chamber: Chamber # List(State);

	% Send
	s_set_pressure: Chamber # Pressure;
	s_set_door: Door # State;
	s_move: Robot # Chamber # Action;
	s_system_want_in;
	s_system_want_out;
	s_wafer_in;
	s_wafer_out;
	s_tray_empty;
	s_pressure_confirmed: Chamber # List(Pressure);
	s_door_confirmed: Door # List(State);
	s_move_confirmed: Robot # List(State);
	
	% Receive
	r_set_pressure: Chamber # Pressure;
	r_set_door: Door # State;
	r_move: Robot # Chamber # Action;
	r_system_want_in;
	r_system_want_out;
	r_wafer_in;
	r_wafer_out;
	r_tray_empty;
	r_pressure_confirmed: Chamber # List(Pressure);
	r_door_confirmed: Door # List(State);
	r_move_confirmed: Robot # List(State);
	
	% Comm
	c_set_pressure: Chamber # Pressure;
	c_set_door: Door # State;
	c_move: Robot # Chamber # Action;
	c_system_want_in;
	c_system_want_out;
	c_wafer_in;
	c_wafer_out;
	c_tray_empty;
	c_pressure_confirmed: Chamber # List(Pressure);
	c_door_confirmed: Door # List(State);
	c_move_confirmed: Robot # List(State);

% We can try to program this anti-chronological, meaning we start with the action/process to remove a wafer, then work backwards


% We can omit the pH because the pressure in the High Vacuum Chamber is always High
proc Pressure_Controller(pressures:List(Pressure), states:List(State)) = (
%	if p == this p -> confirm
%	elseif doors of this room are closed -> confirm and update pressures
%	else -> close doors, wait for confirmation of doors, send confirm and update pressures

	sum p:Pressure.
	(
		sum c:Chamber.
		(
			(r_set_pressure(c, p)
			. (p == gp(pressures, c)) -> s_pressure_confirmed(c, sp(pressures, c, p))
				. Pressure_Controller(pressures, states)
			<>
				((is_chamber_sealed(c, states)) -> s_pressure_confirmed(c, sp(pressures, c, p))
					. Pressure_Controller(sp(pressures, c, p), states)
				<>
					s_seal_chamber(c, states)
					. s_pressure_confirmed(c, sp(pressures, c, p))
					. Pressure_Controller(sp(pressures, c, p), states)
				)
			)
		)
	)
);

proc Door_Controller(states:List(State), pressures:List(Pressure)) = (
%	if door is in requested state -> confirm
%	elseif door open -> close door, confirm
%	elseif pressure is correct -> open door, confirm
%	else -> set pressure, wait for confirm of pressure, open door, confirm
	nop
);

proc Robot_Controller(actions:List(Action), states:List(State)) = (
%	if robot unoccupied ->
%		if door open -> confirm
%		else -> set_door open, wait for confirmation of door, confirm move
%	else break wafer
	nop
);

proc Transport_Controller(numWafersIn, numWafersOut:Int) = (
%	if cI is empty -> wafer_in
%	else -> move, wait for confirm, wafer_in
% +
%	if cO is not empty -> move, wait for confirm, wafer_out




	((numWafersIn >= 1) ->
		r_move(rI, cI, aG)
%		. r_move_confirmed(rI, states)
		. s_wafer_in
		. Transport_Controller(numWafersIn - 1, numWafersOut) 
	<>
		tray_empty 
		. Transport_Controller(numWafersIn, numWafersOut)
	)
	+
	% more actions need to be added here, depending on the order of move and r_wafer_out
	% move(rT,cO,aG) ?
	(
		r_move(rT, cO, aG)
%		. r_move_confirmed(rT, states)
		. r_wafer_out 
		. Transport_Controller(numWafersIn, numWafersOut + 1)
	)
);

proc Test_Controller = (
	nop
);

proc Init_Controller = (
	s_wafer_in
);

proc Seal_Chamber(states:List(State)) = (
	% We would like an array function here based on c2d.
	%sum c:Chamber. r_seal_chamber(c) . 
	(
		r_seal_chamber(cI, states)
		. s_set_door(dAI, sC)
		. r_door_confirmed(dAI, states)
		. s_set_door(dLI, sC)
		. r_door_confirmed(dLI, states)
		. s_seal_confirmed(cI, states)
		+
		r_seal_chamber(cO, states)
		. s_set_door(dAO, sC)
		. r_door_confirmed(dAO, states)
		. s_set_door(dLO, sC)
		. r_door_confirmed(dLO, states)
		. s_seal_confirmed(cO, states)
		+
		r_seal_chamber(cL, states)
		. s_set_door(dLI, sC)
		. r_door_confirmed(dLI, states)
		. s_set_door(dLO, sC)
		. r_door_confirmed(dLO, states)
		. s_set_door(dH, sC)
		. r_door_confirmed(dH, states)
		. s_seal_confirmed(cL, states)
		+
		r_seal_chamber(cH, states)
		. s_set_door(dH, sC)
		. r_door_confirmed(dH, states)
		. s_seal_confirmed(cH, states)
	)
	. Seal_Chamber(states)
);

init
	allow(
		{
			tray_empty,
			
			%s_set_pressure,
			%s_set_door,
			%s_move,
			%s_wafer_in,
			%s_wafer_out,
			%s_pressure_confirmed,
			%s_door_confirmed,
			%s_move_confirmed,
			
			%r_set_pressure,
			%r_set_door,
			%r_move,
			%r_wafer_in,
			%r_wafer_out,
			%r_pressure_confirmed,
			%r_door_confirmed,
			%r_move_confirmed,
			
			c_set_pressure,
			c_set_door,
			c_move,
			c_wafer_in,
			c_wafer_out,
			c_pressure_confirmed,
			c_door_confirmed,
			c_move_confirmed,
			
			
			
			c_seal_confirmed
		},
		comm(
			{
				s_set_pressure | r_set_pressure -> c_set_pressure,
				s_set_door | r_set_door -> c_set_door,
				s_move | r_move -> c_move,
				s_wafer_in | r_wafer_in -> c_wafer_in,
				s_wafer_out | r_wafer_out -> c_wafer_out,
				s_pressure_confirmed | r_pressure_confirmed -> c_pressure_confirmed,
				s_door_confirmed | r_door_confirmed -> c_door_confirmed,
				s_move_confirmed | r_move_confirmed -> c_move_confirmed,
				
				
				s_seal_confirmed | r_seal_confirmed -> c_seal_confirmed
				
				
				
				
				
			},
			Pressure_Controller([pA, pA, pL, pH], [sC, sC, sC, sC, sC]) ||
			Door_Controller([sC, sC, sC, sC, sC], [pA, pA, pL, pH]) ||
			Robot_Controller([aR, aR, aR], [sC, sC, sC, sC, sC]) ||
			Transport_Controller(3, 0) ||
			Test_Controller ||
			Init_Controller ||
			
			
			Seal_Chamber([sC, sC, sC, sC, sC])
		)
	);