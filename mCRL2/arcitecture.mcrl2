sort
	Chamber = struct cI | cO | cL | cH;
	%Chamber = struct cT | cI | cO | cL | cH;
	Pressure = struct pA | pL | pH;
	Door = struct dAI | dAO | dLI | dLO | dH;
	Robot = struct rI | rO | rT;
	DoorState = struct sO | sC;
	Action = struct aG | aR;
%	WaferStatus   = struct wN | wP;

map
	doorsStart: Door -> DoorState;

%	c2d: Chamber -> List(Door); % get list of doors connected to chamber
%	d2c: Door -> List(Chamber); % get list of chambers connected to door
	d2p: Door -> Pressure; % get the required pressure for all of the chambers connected to door
	cr2d: Chamber # Robot -> Door; % get the door that needs to open for a robot to perform any action in a chamber
%	cs2c: Chamber # WaferStatus -> Chamber; % get the next chamber that the wafer needs to move to.
%	c2c2r: Chamber # Chamber -> Robot; % get the robot that will move the wafer to the next chamber.
%	c2c2a: Chamber # Chamber -> Action; % get the action for the robot that will move the wafer to the next chamber.
	
var
	door: Door;

eqn
	doorsStart(door) = sC;

	%c2d(cI) = [dAI, dLI];
	%c2d(cO) = [dAO, dLO];
	%c2d(cL) = [dLI, dLO, dH];
	%c2d(cH) = [dH];

	%d2c(dAI) = [cI];
	%d2c(dAO) = [cO];
	%d2c(dLI) = [cI, cL];
	%d2c(dLO) = [cL, cO];
	%d2c(dH ) = [cL, cH];

	d2p(dAI) = pA;
	d2p(dAO) = pA;
	d2p(dLI) = pL;
	d2p(dLO) = pL;
	d2p(dH ) = pH;

	cr2d(cI, rI) = dLI; %
	cr2d(cI, rT) = dAI; %
	cr2d(cO, rO) = dLO; %
	cr2d(cO, rT) = dAO; %
%	cr2d(cL, rI) = dLI;
%	cr2d(cL, rO) = dLO;
	cr2d(cH, rI) = dH;  %
	cr2d(cH, rO) = dH;  %
%	cr2d(cT, rT) = dAO;
	
%	cr2d(cI, rO) = dLO;
%	cr2d(cO, rI) = dLI;
%	cr2d(cH, rT) = dH;
%	cr2d(cT, rI) = dAI;
%	cr2d(cT, rO) = dAO;
%
%	%cs2c(cT, wP) = cT; % ????????
%	cs2c(cT, wN) = cI;
%	cs2c(cI, wP) = cT;
%	cs2c(cL, wN) = cH;
%	cs2c(cL, wP) = cO;
%	cs2c(cH, wN) = cL; % ????????
%	cs2c(cH, wP) = cL;
%	cs2c(cO, wN) = cL;
%	cs2c(cO, wP) = cT;
%	
%	cs2c(cI, wN) = cL;
%
%	c2c2r(cT,cI) = rT;
%	c2c2r(cI,cL) = rI;
%	c2c2r(cL,cH) = rI;
%	c2c2r(cH,cL) = rO;
%	c2c2r(cL,cO) = rO;
%	c2c2r(cO,cT) = rT;
%	
%	c2c2r(cI,cT) = rT;
%	c2c2r(cT,cO) = rO;
%	c2c2r(cI,cH) = rI;
%	c2c2r(cH,cI) = rI;
%	c2c2r(cO,cH) = rO;
%	c2c2r(cH,cO) = rO;
%	
%	c2c2r(cT,cI) = rT;
%	c2c2r(cO,cL) = rO;
%
%	c2c2a(cT,cI) = aR;
%	c2c2a(cI,cL) = aG;
%	c2c2a(cL,cH) = aR;
%	c2c2a(cH,cL) = aG;
%	c2c2a(cL,cO) = aR;
%	c2c2a(cO,cT) = aG;
%	
%	c2c2a(cI,cT) = aR;
%	c2c2a(cO,cL) = aG;
	

act
	nop;
	nop2;
	nop3;


	% external actions
%	wafer_in;
%	project_wafer;
%	wafer_out;
%	system_finished;

	% communication actions (s = send, r = receive, c = communicate)
	s_door_request, r_door_request, c_door_request: Door # DoorState;
	s_door_confirmed, r_door_confirmed, c_door_confirmed: Door;
	s_door_status, r_door_status, c_door_status: Door # DoorState;
	s_door_lock, r_door_lock, c_door_lock: Door # Bool;

	s_pressure_request, r_pressure_request, c_pressure_request: Chamber # Pressure;
	s_pressure_confirmed, r_pressure_confirmed, c_pressure_confirmed: Chamber;

	s_move_request, r_move_request, c_move_request: Robot # Chamber # Action;
	s_move_confirmed, r_move_confirmed, c_move_confirmed: Robot;

	
	%s_pressure_status, r_pressure_status, c_pressure_status: Chamber # Pressure;

	s_robot_status, r_robot_status, c_robot_status: Robot # Action;

	s_door_set, r_door_set, c_door_set: Door # DoorState;
	s_robot_set_request, r_robot_set_request, c_robot_set_request: Robot # Action;

proc

	pressureController(c:Chamber, status:Pressure) = (%, locked:Bool) = (
	%	if p == this p -> confirm
	%	elseif doors of this room are closed -> confirm and update pressures
	%	else -> close doors, wait for confirmation of doors, send confirm and update pressures
		
		%((!locked) ->
		%	r_pressure_unlock(c) . pressureController(c, p)
		%)
		
		
		sum p:Pressure.
		(
			%s_pressure_status(c, status) . pressureController()
			%+
			r_pressure_request(c, p)
			. ((p == status) -> % if p == pstate -> confirm
					s_pressure_confirmed(c)
					. pressureController()
			<>
	%			sum d:Door.
	%			(
	%				((d in c2d(c)) ->
	%					askCloseDoor(d)
	%				)
	%			)
					
				(
					((c == cI) ->
						askCloseDoor(dAI)
						. askCloseDoor(dLI)
					)
					+ ((c == cO) ->
						askCloseDoor(dAO)
						. askCloseDoor(dLO)
					)
					+ ((c == cL) ->
						askCloseDoor(dLI)
						. askCloseDoor(dLO)
						. askCloseDoor(dH )
					)
					+ ((c == cH) ->
						askCloseDoor(dH )
					)
				)
				. s_pressure_confirmed(c)
				. pressureController(c, p)
			)
		)
	);

	doorStateController(status: Door -> DoorState) = (
		sum d: Door, s: DoorState. 
		(
			s_door_status(d, status(d)) . doorStateController()
		+
			r_door_set(d, s) . doorStateController(status[d -> s])
		)
	);
	
	
	%askSetPressure(d:Door, c:Chamber) = (sum p:Pressure. ( r_pressure_status(c, p) . ((d2p(d) != p) -> s_pressure_request(c, d2p(d)) . r_pressure_confirmed(c) <> nop )));
	askSetPressure(d:Door, c:Chamber) = s_pressure_request(c, d2p(d)) . r_pressure_confirmed(c);
	
	askCloseDoor(d:Door) = r_door_status(d, sO) . s_door_lock(d, true) . s_door_request(d, sC) . r_door_confirmed(d) . s_door_lock(d, false) + r_door_status(d, sC);
	%askCloseDoor(d:Door) = r_door_status(d, sO) . nop2 . s_door_lock(d, true) . nop3 . s_door_request(d, sC) . r_door_confirmed(d) . s_door_lock(d, false) + r_door_status(d, sC);
	%askCloseDoor(d:Door) = r_door_status(d, sO) . s_door_lock(d, true) . s_door_request(d, sC) . r_door_confirmed(d) + r_door_status(d, sC);
	%askCloseDoor(d:Door) = s_door_request(d, sC) . r_door_confirmed(d);
	
	doorController(d:Door) = (
	%	if door is in requested state -> confirm
	%	elseif door open -> close door, confirm
	%	elseif pressure is correct -> open door, confirm
	%	else -> set pressure, wait for confirm of pressure, open door, confirm

		sum s:DoorState.
		(
			r_door_lock(d, true)
			. r_door_request(d, s)
			. sum ds:DoorState.
			(
				r_door_status(d, ds)
				. ((ds == s) -> % The door is in the requested state
					s_door_confirmed(d)
					. r_door_lock(d, false)
					. doorController(d)
				<>
					((ds == sO) -> % The door is open and must be closed
						s_door_set(d, s)
						. s_door_confirmed(d)
						. r_door_lock(d, false)
						. doorController(d)
					<> % The door is closed and must be opened
					
	%					sum c:Chamber.
	%					(					
	%						((c in d2c(d)) ->
	%							askSetPressure(d, c)
	%						)
	%					)
						
						(
							((d == dAI) ->
								askSetPressure(d, cI)
							)
							+
							((d == dAO) ->
								askSetPressure(d, cO)
							)
							+
							((d == dLI) ->
								askSetPressure(d, cI)
								. askSetPressure(d, cL)
							)
							+
							((d == dLO) ->
								askSetPressure(d, cL)
								. askSetPressure(d, cO)
							)
							+
							((d == dH ) ->
								askSetPressure(d, cL)
								. askSetPressure(d, cH)
							)
						)
						
						. s_door_set(d, s)
						. s_door_confirmed(d)
						. r_door_lock(d, false)
						. doorController(d)
					)
				)
			)
		)
	);

	Move(r:Robot, c:Chamber, a:Action) = (
		sum as:Action.
		(
			r_robot_status(r, as)
			. ((a == as) ->
				Move()
			<>
				s_move_request(r, c, a)
				. r_move_confirmed(r)
			)
		)
	);

	robotController(r:Robot, status:Action) = (%, locked:Bool) = (
	%	if robot unoccupied ->
	%		if door open -> confirm
	%		else -> set_door open, wait for confirmation of door, confirm move
	%	else break wafer
		%r_robot_lock(r, True) . robotController(r, a, True)
		%+
		sum a:Action.
		(
			s_robot_status(r, status) . robotController()
			+
			r_robot_set_request(r, a) . robotController(r, a)
			+
			sum c:Chamber.
			(
				r_move_request(r, c, a)
				% Open the required door for the robot
				. s_door_lock(cr2d(c, r), true)
				. s_door_request(cr2d(c, r), sO)
				. r_door_confirmed(cr2d(c, r))
				. s_move_confirmed(r)
				. s_door_lock(cr2d(c, r), false)
				. robotController(r, a)
			)
		)
	);

%	waferController1(c:Chamber, ws: WaferStatus) = (
%
%	%cs2c
%	%c2c2r
%	%c2c2a
%
%	%nc = cs2c(c, ws)
%	%a = c2c2a(c, nc)
%	%r = c2c2r(c, nc)
%
%	%s_move_request(r, c, a)
%
%		sum c:Chamber, ws: WaferStatus.
%		(
%			((c == cT && ws == wP) ->
%				Move(rT, cT, aR)
%%				. wafer_out
%			<>
%				Move(c2c2r(c, cs2c(c, ws)), cs2c(c, ws), c2c2a(c, cs2c(c, ws)))
%				. waferController1(cs2c(c, ws), ws)
%				%. waferController1(cT, wP)
%			)
%		)
%	);
	
	waferController = (
%		wafer_in
		s_move_request(rT, cI, aR)
		. r_move_confirmed(rT)
		. Move(rI, cI, aG)
		. Move(rI, cH, aR)
		. Move(rO, cH, aG)
		. Move(rO, cO, aR)
		. s_move_request(rT, cO, aG)
		. r_move_confirmed(rT)
%		. wafer_out
%		. waferController
	);
	
	waferController5 = (
%		wafer_in
		Move(rI, cI, aG)
		. Move(rI, cH, aR)
%		. wafer_out
		. waferController5
	);

	transportController = (
		waferController %|| waferController || waferController || waferController || waferController
	);

	%transportController(numWafers: Int) = (
	%	((numWafers > 0) ->
	%		wafer_in . (waferController(cT, wN) || waferController(cT, wN))
	%		%wafer_in . (transportController(numWafers - 1) )%|| waferController(cT, wN))
    %
	%	<>
	%		system_finished %. transportController(0)
	%	)
	%);


init
hide(
	{
		%c_door_status,
		%%c_pressure_status,
		%c_robot_status,
		%c_door_set,
		nop
	},
	allow(
		{
			nop,
			nop2,
			nop3,
			c_pressure_request,
			c_pressure_confirmed,
			c_door_request,
			c_door_confirmed,
			c_move_request,
			c_move_confirmed,
%			wafer_in,
	%		project_wafer,
%			wafer_out,
%			system_finished,

			c_door_status,
			%c_pressure_status,
			c_robot_status,

			c_door_set,
			c_door_lock

		},
		comm(
			{
				s_door_request  		| r_door_request 		-> c_door_request,
				s_door_confirmed  		| r_door_confirmed 		-> c_door_confirmed,
				s_pressure_request  	| r_pressure_request 	-> c_pressure_request,
				s_pressure_confirmed  	| r_pressure_confirmed 	-> c_pressure_confirmed,
				s_move_request 			| r_move_request		-> c_move_request,
				s_move_confirmed	  	| r_move_confirmed 		-> c_move_confirmed,
				s_door_status 			| r_door_status			-> c_door_status,
				%s_pressure_status 		| r_pressure_status		-> c_pressure_status,
				s_robot_status 			| r_robot_status		-> c_robot_status,

				s_door_set		 		| r_door_set			-> c_door_set,
				s_door_lock				| r_door_lock			-> c_door_lock

			},
			pressureController(cI, pA) ||
			pressureController(cO, pL) ||
			pressureController(cL, pL) ||
			pressureController(cH, pH) ||
			doorStateController(doorsStart) ||
			doorController(dAI) ||
			doorController(dAO) ||
			doorController(dLI) ||
			doorController(dLO) ||
			doorController(dH ) ||
			robotController(rT, aR) ||
			robotController(rI, aR) ||
			robotController(rO, aR) ||
			transportController
		)
	)
);