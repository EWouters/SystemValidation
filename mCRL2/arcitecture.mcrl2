sort
	Chamber = struct cI | cO | cL | cH;
	%Chamber = struct cT | cI | cO | cL | cH;
	Pressure = struct pA | pL | pH;
	Door = struct dAI | dAO | dLI | dLO | dH;
	Robot = struct rI | rO | rT;
	DoorState = struct sO | sC;
	Action = struct aG | aR;
%	WaferStatus   = struct wN | wP;

map
	doorsStart: Door -> DoorState;

%	c2d: Chamber -> List(Door); % get list of doors connected to chamber
%	d2c: Door -> List(Chamber); % get list of chambers connected to door
	d2p: Door -> Pressure; % get the required pressure for all of the chambers connected to door
	cr2d: Chamber # Robot -> Door; % get the door that needs to open for a robot to perform any action in a chamber
%	cs2c: Chamber # WaferStatus -> Chamber; % get the next chamber that the wafer needs to move to.
%	c2c2r: Chamber # Chamber -> Robot; % get the robot that will move the wafer to the next chamber.
%	c2c2a: Chamber # Chamber -> Action; % get the action for the robot that will move the wafer to the next chamber.
	
var
	door: Door;

eqn
	doorsStart(door) = sC;

	%c2d(cI) = [dAI, dLI];
	%c2d(cO) = [dAO, dLO];
	%c2d(cL) = [dLI, dLO, dH];
	%c2d(cH) = [dH];

	%d2c(dAI) = [cI];
	%d2c(dAO) = [cO];
	%d2c(dLI) = [cI, cL];
	%d2c(dLO) = [cL, cO];
	%d2c(dH ) = [cL, cH];

	d2p(dAI) = pA;
	d2p(dAO) = pA;
	d2p(dLI) = pL;
	d2p(dLO) = pL;
	d2p(dH ) = pH;

	cr2d(cI, rI) = dLI; %
	cr2d(cI, rT) = dAI; %
	cr2d(cO, rO) = dLO; %
	cr2d(cO, rT) = dAO; %
%	cr2d(cL, rI) = dLI;
%	cr2d(cL, rO) = dLO;
	cr2d(cH, rI) = dH;  %
	cr2d(cH, rO) = dH;  %
%	cr2d(cT, rT) = dAO;
	
%	cr2d(cI, rO) = dLO;
%	cr2d(cO, rI) = dLI;
%	cr2d(cH, rT) = dH;
%	cr2d(cT, rI) = dAI;
%	cr2d(cT, rO) = dAO;
%
%	%cs2c(cT, wP) = cT; % ????????
%	cs2c(cT, wN) = cI;
%	cs2c(cI, wP) = cT;
%	cs2c(cL, wN) = cH;
%	cs2c(cL, wP) = cO;
%	cs2c(cH, wN) = cL; % ????????
%	cs2c(cH, wP) = cL;
%	cs2c(cO, wN) = cL;
%	cs2c(cO, wP) = cT;
%	
%	cs2c(cI, wN) = cL;
%
%	c2c2r(cT,cI) = rT;
%	c2c2r(cI,cL) = rI;
%	c2c2r(cL,cH) = rI;
%	c2c2r(cH,cL) = rO;
%	c2c2r(cL,cO) = rO;
%	c2c2r(cO,cT) = rT;
%	
%	c2c2r(cI,cT) = rT;
%	c2c2r(cT,cO) = rO;
%	c2c2r(cI,cH) = rI;
%	c2c2r(cH,cI) = rI;
%	c2c2r(cO,cH) = rO;
%	c2c2r(cH,cO) = rO;
%	
%	c2c2r(cT,cI) = rT;
%	c2c2r(cO,cL) = rO;
%
%	c2c2a(cT,cI) = aR;
%	c2c2a(cI,cL) = aG;
%	c2c2a(cL,cH) = aR;
%	c2c2a(cH,cL) = aG;
%	c2c2a(cL,cO) = aR;
%	c2c2a(cO,cT) = aG;
%	
%	c2c2a(cI,cT) = aR;
%	c2c2a(cO,cL) = aG;
	

act
	nop;
	nop2;
	nop3;


	% external actions
	wafer_in;
%	project_wafer;
	wafer_out;
%	system_finished;

	% communication actions (s = send, r = receive, c = communicate)
	s_door_request, r_door_request, c_door_request: Door # DoorState;
	s_door_confirmed, r_door_confirmed, c_door_confirmed: Door # DoorState;
	s_door_status, r_door_status, c_door_status: Door # DoorState;
	s_door_locked, r_door_locked, c_door_locked: Door # Bool;
	s_door_lock, r_door_lock, c_door_lock: Door # Bool;

	s_pressure_request, r_pressure_request, c_pressure_request: Chamber # Pressure;
	s_pressure_confirmed, r_pressure_confirmed, c_pressure_confirmed: Chamber # Pressure;
	s_pressure_status, r_pressure_status, c_pressure_status: Chamber # Pressure;

	s_move_request, r_move_request, c_move_request: Robot # Chamber # Action;
	s_move_confirmed, r_move_confirmed, c_move_confirmed: Robot # Chamber # Action;

	%s_pressure_status, r_pressure_status, c_pressure_status: Chamber # Pressure;

	s_robot_status, r_robot_status, c_robot_status: Robot # Action;

	s_door_set, r_door_set, c_door_set: Door # DoorState;
	%s_robot_set_request, r_robot_set_request, c_robot_set_request: Robot # Action;

proc
	Set_Pressure(c:Chamber, p:Pressure) = (
		sum ps:Pressure.
		(
			r_pressure_status(c, ps)
			. ((ps != p) ->
				s_pressure_request(c, p)
				. r_pressure_confirmed(c, p)
			<>
				nop3
			)
		)
	);
	
	pressureController(c:Chamber, status:Pressure) = (
	%	if p == this p -> confirm
	%	elseif doors of this room are closed -> confirm and update pressures
	%	else -> close doors, wait for confirmation of doors, send confirm and update pressures
		
		s_pressure_status(c, status) . pressureController()
		+
		sum p:Pressure.
		(
			r_pressure_request(c, p)
			. ((p == status) -> % if p == pstate -> confirm
					s_pressure_confirmed(c, p)
					. pressureController()
			<>
%				sum d:Door.
%				(
%					((d in c2d(c)) ->
%						Set_Door(d, sC)
%					)
%				)
					
				(
					((c == cI) ->
						Set_Door(dAI, sC)
						. Set_Door(dLI, sC)
					)
					+ ((c == cO) ->
						Set_Door(dAO, sC)
						. Set_Door(dLO, sC)
					)
					+ ((c == cL) ->
						Set_Door(dLI, sC)
						. Set_Door(dLO, sC)
						. Set_Door(dH , sC)
					)
					+ ((c == cH) ->
						Set_Door(dH , sC)
					)
				)
				. s_pressure_confirmed(c, p)
				. pressureController(c, p)
			)
		)
	);

	doorStateController(status: Door -> DoorState) = (
		sum d: Door, s: DoorState. 
		(
			s_door_status(d, status(d)) . doorStateController()
		+
			r_door_set(d, s) . doorStateController(status[d -> s])
		)
	);
	
	
	%askSetPressure(d:Door, c:Chamber) = (sum p:Pressure. ( r_pressure_status(c, p) . ((d2p(d) != p) -> s_pressure_request(c, d2p(d)) . r_pressure_confirmed(c, p) <> nop )));
	%askSetPressure(d:Door, c:Chamber) = Set_Pressure(c, d2p(d)) . s_pressure_lock(c, false);
	
	%askCloseDoor(d:Door) = r_door_status(d, sO) . Set_Door(d, sC) + r_door_status(d, sC) . s_door_lock(d, true);
	
	Set_Door(d:Door, ds:DoorState) = (
		sum locked:Bool.
		(
			r_door_locked(d, locked)
			. ((locked) ->
				sum s:DoorState.
				(
					r_door_status(d, s)
					. ((ds != s) ->
						Set_Door()
					<>
						nop3
					)
				)
			<>
				s_door_lock(d, true)
				. s_door_request(d, ds)
				. r_door_confirmed(d, ds)
			)
		)
	);
	
	doorController(d:Door, locked:Bool) = (
	%	if door is in requested state -> confirm
	%	elseif door open -> close door, confirm
	%	elseif pressure is correct -> open door, confirm
	%	else -> set pressure, wait for confirm of pressure, open door, confirm

		s_door_locked(d, locked) . doorController()
		+
		((locked) ->
			% If the door state is locked the doorController can receive an unlock action or a r_door_request
			(r_door_lock(d, false) . doorController(d, false)
			+
			sum s:DoorState.
			(
				r_door_request(d, s)
				. sum ds:DoorState.
				(
					r_door_status(d, ds)
					. ((ds == s) -> % The door is in the requested state
						s_door_confirmed(d, s)
						. doorController(d, locked)
					<>
						((ds == sO) -> % The door is open and must be closed
							s_door_set(d, s)
							. s_door_confirmed(d, s)
							. doorController(d, locked)
						<> % The door is closed and must be opened
							(
								((d == dAI) ->
									Set_Pressure(cI, d2p(d))
								)
								+
								((d == dAO) ->
									Set_Pressure(cO, d2p(d))
								)
								+
								((d == dLI) ->
									Set_Pressure(cI, d2p(d))
									. Set_Pressure(cL, d2p(d))
								)
								+
								((d == dLO) ->
									Set_Pressure(cL, d2p(d))
									. Set_Pressure(cO, d2p(d))
								)
								+
								((d == dH ) ->
									Set_Pressure(cL, d2p(d))
									. Set_Pressure(cH, d2p(d))
								)
							)
							. s_door_set(d, s)
							. s_door_confirmed(d, s)
							% Wait here for robot confirmed ???
							. doorController(d, locked)
						)
					)
				))
			)
		<>
			% If the door state is unlocked the doorController can only receive a lock action, which will lock the door state
			r_door_lock(d, true) . doorController(d, true)
		)
	);

	Move(r:Robot, c:Chamber, a:Action) = (
		sum as:Action.
		(
			r_robot_status(r, as)
			. ((a == as) ->
				Move()
			<>
				s_move_request(r, c, a)
				. r_move_confirmed(r, c, a)
			)
		)
	);

	robotController(r:Robot, status:Action) = (
	%	if robot unoccupied ->
	%		if door open -> confirm
	%		else -> set_door open, wait for confirmation of door, confirm move
	%	else break wafer

		sum a:Action.
		(
			s_robot_status(r, status) . robotController()
			+
			%r_robot_set_request(r, a) . robotController(r, a)
			%+
			sum c:Chamber.
			(
				r_move_request(r, c, a)
				% Open the required door for the robot
				. Set_Door(cr2d(c, r), sO)
				. s_move_confirmed(r, c, a)
				. s_door_lock(cr2d(c, r), false)
				. robotController(r, a)
			)
		)
	);

%	waferController1(c:Chamber, ws: WaferStatus) = (
%
%	%cs2c
%	%c2c2r
%	%c2c2a
%
%	%nc = cs2c(c, ws)
%	%a = c2c2a(c, nc)
%	%r = c2c2r(c, nc)
%
%	%s_move_request(r, c, a)
%
%		sum c:Chamber, ws: WaferStatus.
%		(
%			((c == cT && ws == wP) ->
%				Move(rT, cT, aR)
%%				. wafer_out
%			<>
%				Move(c2c2r(c, cs2c(c, ws)), cs2c(c, ws), c2c2a(c, cs2c(c, ws)))
%				. waferController1(cs2c(c, ws), ws)
%				%. waferController1(cT, wP)
%			)
%		)
%	);
	
	waferController = (
		wafer_in
		. s_move_request(rT, cI, aR)
		. r_move_confirmed(rT, cI, aR)
		. s_door_lock(cr2d(cI, rT), false)
		. Move(rI, cI, aG)
		. Move(rI, cH, aR)
		. Move(rO, cH, aG)
		. Move(rO, cO, aR)
		. s_move_request(rT, cO, aG)
		. r_move_confirmed(rT, cO, aG)
		. s_door_lock(cr2d(cO, rT), false)
		. wafer_out
%		. waferController
	);
	
	waferController5 = (
%		wafer_in
		Move(rI, cI, aG)
		. Move(rI, cH, aR)
%		. wafer_out
		. waferController5
	);
	
	transportController = (
		waferController %|| waferController %|| waferController || waferController || waferController
	);

	%transportController(numWafers: Int) = (
	%	((numWafers > 0) ->
	%		wafer_in . (waferController(cT, wN) || waferController(cT, wN))
	%		%wafer_in . (transportController(numWafers - 1) )%|| waferController(cT, wN))
    %
	%	<>
	%		system_finished %. transportController(0)
	%	)
	%);


init
hide(
	{
		%c_door_status,
		%%c_pressure_status,
		%c_robot_status,
		%c_door_set,
		nop
	},
	allow(
		{
			nop,
			nop2,
			nop3,
			c_pressure_request,
			c_pressure_confirmed,
			
			
			%s_pressure_request,
			%s_door_request,
			
			
			c_door_request,
			c_door_confirmed,
			c_door_lock,
			c_door_locked,
			
			c_move_request,
			c_move_confirmed,
			wafer_in,
	%		project_wafer,
			wafer_out,
%			system_finished,

			c_door_status,
			
			c_pressure_status,
			%c_robot_status,

			c_door_set

		},
		comm(
			{
				s_door_request  		| r_door_request 		-> c_door_request,
				s_door_confirmed  		| r_door_confirmed 		-> c_door_confirmed,
				s_door_lock		 		| r_door_lock			-> c_door_lock,
				s_door_locked			| r_door_locked			-> c_door_locked,
				
				s_pressure_request  	| r_pressure_request 	-> c_pressure_request,
				s_pressure_confirmed  	| r_pressure_confirmed 	-> c_pressure_confirmed,
				
				s_move_request 			| r_move_request		-> c_move_request,
				s_move_confirmed	  	| r_move_confirmed 		-> c_move_confirmed,
				
				s_door_status 			| r_door_status			-> c_door_status,
				s_pressure_status 		| r_pressure_status		-> c_pressure_status,
				%s_robot_status 			| r_robot_status		-> c_robot_status,

				s_door_set		 		| r_door_set			-> c_door_set

			},
			pressureController(cI, pA) ||
			pressureController(cO, pL) ||
			pressureController(cL, pL) ||
			pressureController(cH, pH) ||
			doorStateController(doorsStart) ||
			doorController(dAI, false) ||
			doorController(dAO, false) ||
			doorController(dLI, false) ||
			doorController(dLO, false) ||
			doorController(dH , false) ||
			robotController(rT, aR) ||
			robotController(rI, aR) ||
			robotController(rO, aR) ||
			transportController
		)
	)
);