sort
	Chamber = struct cI | cO | cL | cH;
	Pressure = struct pA | pL | pH;
	Door = struct dAI | dAO | dLI | dLO | dH;
	Robot = struct rI | rO | rT;
	State = struct sO | sC;
	Action = struct aG | aR;

map
	sp: List(Pressure) # Chamber # Pressure -> List(Pressure);
	gp: List(Pressure) # Chamber -> Pressure;
	sd: List(State) # Door # State -> List(State);
	gd: List(State) # Door -> State;
	sr: List(Action) # Robot # Action -> List(Action);
	gr: List(Action) # Robot -> Action;

	c2d: Chamber -> List(Door); % get list of doors connected to chamber
	d2c: Door -> List(Chamber); % get list of chambers connected to door
	d2p: Door -> Pressure; % get the required pressure for all of the chambers connected to door
	cr2d: Chamber # Robot -> Door; % get the door that needs to open for a robot to perform any action in a chamber
	
	can_door_open: Door # List(Pressure) -> Bool;
	is_chamber_sealed: Chamber # List(State) -> Bool;
	is_robot_occupied: Robot # List(Action) -> Bool;

var
	pressures: List(Pressure);
	pressure: Pressure;
	actions: List(Action);
	action: Action;
	states: List(State);
	state: State;

eqn
	% Dictionary for Chamber to list of Pressures
	sp(pressures, cI, pressure) = [pressure] ++ tail(pressures);
	sp(pressures, cO, pressure) = [head(pressures), pressure] ++ tail(tail(pressures));
	sp(pressures, cL, pressure) = rtail(rtail(pressures)) ++ [pressure, rhead(pressures)];
	sp(pressures, cH, pressure) = rtail(pressures) ++ [pressure];
	gp(pressures, cI) = head(pressures);
	gp(pressures, cO) = head(tail(pressures));
	gp(pressures, cL) = rhead(rtail(pressures));
	gp(pressures, cH) = rhead(pressures);
	
	% Dictionary for Door to list of States
	sd(states, dAI, state) = [state] ++ tail(states);
	sd(states, dAO, state) = [head(states), state] ++ tail(tail(states));
	sd(states, dLI, state) = rtail(rtail(rtail(states))) ++ [state] ++ tail(tail(tail(states)));
	sd(states, dLO, state) = rtail(rtail(states)) ++ [state, rhead(states)];
	sd(states, dH,  state) = rtail(states) ++ [state];
	gd(states, dAI) = head(states);
	gd(states, dAO) = head(tail(states));
	gd(states, dLI) = head(tail(tail(states)));
	gd(states, dLO) = rhead(rtail(states));
	gd(states, dH ) = rhead(states);

	% Dictionary for Robot to list of Actions
	sr(actions, rI, action) = [action] ++ tail(actions);
	sr(actions, rO, action) = [head(actions), action, rhead(actions)];
	sr(actions, rT, action) = rtail(actions) ++ [action];
	gr(actions, rI) = head(actions);
	gr(actions, rO) = head(tail(actions));
	gr(actions, rT) = rhead(actions);

	c2d(cI) = [dAI, dLI];
	c2d(cO) = [dAO, dLO];
	c2d(cL) = [dLI, dLO, dH];
	c2d(cH) = [dH];

	d2c(dAI) = [cI];
	d2c(dAO) = [cO];
	d2c(dLI) = [cI, cL];
	d2c(dLO) = [cL, cO];
	d2c(dH ) = [cL, cH];
	
	d2p(dAI) = pA;
	d2p(dAO) = pA;
	d2p(dLI) = pL;
	d2p(dLO) = pL;
	d2p(dH ) = pH;
	
	cr2d(cI, rI) = dAI;
	cr2d(cI, rT) = dAI;
	cr2d(cO, rO) = dAO;
	cr2d(cO, rT) = dAO;
	cr2d(cL, rI) = dLI;
	cr2d(cL, rO) = dLO;
	cr2d(cH, rI) = dH;
	cr2d(cH, rO) = dH;

	can_door_open(dAI, pressures) = (gp(pressures, cI) == pA);
	can_door_open(dAO, pressures) = (gp(pressures, cO) == pA);
	can_door_open(dLI, pressures) = (gp(pressures, cI) == pL) && (gp(pressures, cL) == pL);
	can_door_open(dLO, pressures) = (gp(pressures, cO) == pL) && (gp(pressures, cL) == pL);
	can_door_open(dH,  pressures) = (gp(pressures, cL) == pH);

	is_chamber_sealed(cI, states) = (gd(states, dAI) == sC) && (gd(states, dLI) == sC);
	is_chamber_sealed(cO, states) = (gd(states, dAO) == sC) && (gd(states, dLO) == sC);
	is_chamber_sealed(cL, states) = (gd(states, dLI) == sC) && (gd(states, dLO) == sC) && (gd(states, dH ) == sC);
	is_chamber_sealed(cH, states) = (gd(states, dH ) == sC);
	
	is_robot_occupied(rI, actions) = actions.1 == aG;
	is_robot_occupied(rO, actions) = actions.2 == aG;
	is_robot_occupied(rT, actions) = actions.3 == aG;

act
	tray_empty;
	nop;

	% Send
	s_set_pressure: Chamber # Pressure;
	s_set_door: Door # State;
	s_move: Robot # Chamber # Action;
	s_system_want_in;
	s_system_want_out;
	s_wafer_in;
	s_wafer_out;
	s_tray_empty;
	s_pressure_confirmed: Chamber # List(Pressure);
	s_door_confirmed: Door # List(State);
	s_move_confirmed: Robot # List(Action);
	
	% Receive
	r_set_pressure: Chamber # Pressure;
	r_set_door: Door # State;
	r_move: Robot # Chamber # Action;
	r_system_want_in;
	r_system_want_out;
	r_wafer_in;
	r_wafer_out;
	r_tray_empty;
	r_pressure_confirmed: Chamber # List(Pressure);
	r_door_confirmed: Door # List(State);
	r_move_confirmed: Robot # List(Action);
	
	% Comm
	c_set_pressure: Chamber # Pressure;
	c_set_door: Door # State;
	c_move: Robot # Chamber # Action;
	c_system_want_in;
	c_system_want_out;
	c_wafer_in;
	c_wafer_out;
	c_tray_empty;
	c_pressure_confirmed: Chamber # List(Pressure);
	c_door_confirmed: Door # List(State);
	c_move_confirmed: Robot # List(Action);

% We can omit the pH because the pressure in the High Vacuum Chamber is always High
proc Pressure_Controller(pressures:List(Pressure), states:List(State)) = (
%	if p == this p -> confirm
%	elseif doors of this room are closed -> confirm and update pressures
%	else -> close doors, wait for confirmation of doors, send confirm and update pressures

	sum p:Pressure, c:Chamber.
	(
		r_set_pressure(c, p)
		. ((p == gp(pressures, c)) ->
		(
			s_pressure_confirmed(c, sp(pressures, c, p))
			. Pressure_Controller(pressures, states)
		)
		<> 
			((is_chamber_sealed(c, states)) ->
				s_pressure_confirmed(c, sp(pressures, c, p))
				. Pressure_Controller(sp(pressures, c, p), states)
			<>
				sum d:Door.
				(
					((d in c2d(c)) -> 
						s_set_door(d, sC)
						. r_door_confirmed(d, states)
					)
				)
				. s_pressure_confirmed(c, sp(pressures, c, p))
				. Pressure_Controller(sp(pressures, c, p), states)
			)
		)
	)
);

proc Door_Controller(states:List(State), pressures:List(Pressure)) = (
%	if door is in requested state -> confirm
%	elseif door open -> close door, confirm
%	elseif pressure is correct -> open door, confirm
%	else -> set pressure, wait for confirm of pressure, open door, confirm
	sum s:State, d:Door.
	(
		r_set_door(d, s)
		. ((s == gd(states, d)) -> 
			% The door is in the requested state
			s_door_confirmed(d, sd(states, d, s))
			. Door_Controller(states, pressures)
		<> 
			((gd(states, d) == sO) -> 
				% The door is open and must be closed
				s_door_confirmed(d, sd(states, d, s)) % s==sC always
				. Door_Controller(sd(states, d, s), pressures)
			<>
				((can_door_open(d, pressures)) ->
					% The door is closed and can open
					s_door_confirmed(d, sd(states, d, s))
					. Door_Controller(sd(states, d, s), pressures)
				<>	% Each chamber adjacent to the door should be adjusted to the correct pressure
					sum c:Chamber.
					(
						((c in d2c(d)) -> 
							s_set_pressure(c, d2p(d))
							. r_pressure_confirmed(c, pressures)
						)
					)
					. s_door_confirmed(d, sd(states, d, s))
					. Door_Controller(sd(states, d, s), pressures)
				)
			)
		)
	)
);

proc Robot_Controller(actions:List(Action), states:List(State)) = (
%	if robot unoccupied ->
%		if door open -> confirm
%		else -> set_door open, wait for confirmation of door, confirm move
%	else break wafer

	% When an r_wafer_in action happens, move the wafer to cI
	r_wafer_in . s_move(rT, cI, aR) . Robot_Controller(actions, states)
	+
	sum a:Action, r:Robot, c:Chamber.
	(
		r_move(r, c, a)
		. ((is_robot_occupied(r, actions)) ->
			% The robot is occupied, so self loop   NOTE: can we make the actions list global for this?
			nop
%			s_move(r, c, a) . Robot_Controller(actions, states)
		<>	% The robot is available
			% Open the required door for the robot
			s_set_door(cr2d(c, r), sO)
			. r_door_confirmed(cr2d(c, r), states)
			. ((r == rT) ->
				% The transport robot gets a command
				((c == cI && a == aR) ->
					s_move_confirmed(r, actions)
					. s_move(rI, cI, aG) % route wafer from cI to cL
					. Robot_Controller(actions, states)
				<>
					((c == cO && a == aG) ->
						s_move_confirmed(r, actions)
						. s_wafer_out % route wafer to output tray
						. Robot_Controller(actions, states)
					)
				)
			<>
				((r == rI) ->
					% The input robot gets a command
					((c == cI && a == aG) ->
						s_move_confirmed(r, sr(actions, r, a))
						. s_move(rI, cH, aR) % route wafer from cI to cH
						. Robot_Controller(sr(actions, r, a), states)
					<> ((c == cH && a == aR) ->
							s_move_confirmed(r, sr(actions, r, a))
							. s_move(rO, cH, aG) % route wafer from cH to cO
							. Robot_Controller(sr(actions, r, a), states)
						<>
							nop % We could route the wafer in the opposite directions here
						)
					)
				<>
					((r == rO) ->
						% The output robot gets a command
						((c == cH && a == aG) ->
							s_move_confirmed(r, sr(actions, r, a))
							. s_move(rO, cO, aR) % route wafer from cH to cO
							. Robot_Controller(sr(actions, r, a), states)
						<> ((c == cO && a == aR) ->
								s_move_confirmed(r, sr(actions, r, a))
								. s_move(rT, cO, aG) % route wafer from cO to wafer_out
								. Robot_Controller(sr(actions, r, a), states)
							<>
								nop % We could route the wafer in the opposite directions here
							)
						)
					)
				)
			)
		)
	)
		
		
		
		
		
		
		
%		. ((r == rT) ->
%		% The transport robot gets a command
%			((c == cI) ->
%				s_set_door(dAI, sO)
%				. r_door_confirmed(dAI, states)
%				. ((a == aR) ->
%					. s_move_confirmed(r, c, a)
%				<> % (a == aG)
%					
%				)
%			<>
%				nop
%			)
%		<>
%			nop
%		)

	
%		(
%			(a == aG) ->
%			(
%				(c == cI) -> s_set_door(cI,pL) <>
%				(c == cH) -> s_set_pressure(cL,pH)
%			) <>
%			(a == aR) ->
%			(
%				(c == cH) -> s_set_pressure(cL,pH) <>
%				(c == cO) -> s_set_pressure(cO,pA)
%			)
%		) . 
%		%s_open door . 
%		Robot_Controller(robots,r)
%	)
	
	%Robot_Controller(robots, robot)
	
	
	%s_move(rI,cI,aR) . Robot_Controller(robots, robot)
	
%	sum r:Robot, c:Chamber, a:Action.
%	(
%		((r == rT && a == aR) ->
%			r_move(rT, c, aR)
%			. 
%		)
%		
%		
%		r_move(rT, cI, a)
%		. ((true == true) ->
%			nop
%		)
%	)
);

proc Transport_Controller(numWafersIn, numWafersOut:Int) = (
%	if cI is empty -> wafer_in
%	else -> move, wait for confirm, wafer_in
% +
%	if cO is not empty -> move, wait for confirm, wafer_out




	((numWafersIn >= 1) ->
		r_move(rI, cI, aG)
%		. r_move_confirmed(rI, states)
		. s_wafer_in
		. Transport_Controller(numWafersIn - 1, numWafersOut) 
	<>
		tray_empty 
		. Transport_Controller(numWafersIn, numWafersOut)
	)
	+
	% more actions need to be added here, depending on the order of move and r_wafer_out
	% move(rT,cO,aG) ?
	(
		r_move(rT, cO, aG)
%		. r_move_confirmed(rT, states)
		. r_wafer_out 
		. Transport_Controller(numWafersIn, numWafersOut + 1)
	)
);

proc Test_Controller = (
	nop
);

proc Init_Controller = (
	s_wafer_in
);

%proc Seal_Chamber(states:List(State)) = (
%	% We would like an array function here based on c2d.
%	sum c:Chamber. 
%	(
%		r_seal_chamber(c, states)
%		. sum d:Door.
%		(
%			((d in c2d(c)) -> 
%				s_set_door(d, sC)
%				. r_door_confirmed(d, states)
%			)
%		)
%		. s_seal_confirmed(c, states)
%	)
%	
%	
%	(
%		r_seal_chamber(cI, states)
%		. s_set_door(dAI, sC)
%		. r_door_confirmed(dAI, states)
%		. s_set_door(dLI, sC)
%		. r_door_confirmed(dLI, states)
%		. s_seal_confirmed(cI, states)
%		+
%		r_seal_chamber(cO, states)
%		. s_set_door(dAO, sC)
%		. r_door_confirmed(dAO, states)
%		. s_set_door(dLO, sC)
%		. r_door_confirmed(dLO, states)
%		. s_seal_confirmed(cO, states)
%		+
%		r_seal_chamber(cL, states)
%		. s_set_door(dLI, sC)
%		. r_door_confirmed(dLI, states)
%		. s_set_door(dLO, sC)
%		. r_door_confirmed(dLO, states)
%		. s_set_door(dH, sC)
%		. r_door_confirmed(dH, states)
%		. s_seal_confirmed(cL, states)
%		+
%		r_seal_chamber(cH, states)
%		. s_set_door(dH, sC)
%		. r_door_confirmed(dH, states)
%		. s_seal_confirmed(cH, states)
%	)
%	. Seal_Chamber(states)
%);

init
	allow(
		{
			tray_empty,
			nop,
			
			%s_set_pressure,
			%s_set_door,
			%s_move,
			%s_wafer_in,
			%s_wafer_out,
			%s_pressure_confirmed,
			%s_door_confirmed,
			%s_move_confirmed,
			
			%r_set_pressure,
			%r_set_door,
			%r_move,
			%r_wafer_in,
			%r_wafer_out,
			%r_pressure_confirmed,
			%r_door_confirmed,
			%r_move_confirmed,
			
			c_set_pressure,
			c_set_door,
			c_move,
			c_wafer_in,
			c_wafer_out,
			c_pressure_confirmed,
			c_door_confirmed,
			c_move_confirmed
			
			
			
		},
		comm(
			{
				s_set_pressure | r_set_pressure -> c_set_pressure,
				s_set_door | r_set_door -> c_set_door,
				s_move | r_move -> c_move,
				s_wafer_in | r_wafer_in -> c_wafer_in,
				s_wafer_out | r_wafer_out -> c_wafer_out,
				s_pressure_confirmed | r_pressure_confirmed -> c_pressure_confirmed,
				s_door_confirmed | r_door_confirmed -> c_door_confirmed,
				s_move_confirmed | r_move_confirmed -> c_move_confirmed
				
				
				
				
				
				
				
			},
			Pressure_Controller([pA, pA, pL, pH], [sC, sC, sC, sC, sC]) ||
			Door_Controller([sC, sC, sC, sC, sC], [pA, pA, pL, pH]) ||
			Robot_Controller([aR, aR, aG], [sC, sC, sC, sC, sC]) ||
			Transport_Controller(3, 0) ||
			Test_Controller ||
			Init_Controller %||
			
			
%			Seal_Chamber([sC, sC, sC, sC, sC])
		)
	);