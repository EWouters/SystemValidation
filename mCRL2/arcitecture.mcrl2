sort
	Chamber = struct cI | cO | cL | cH;
	Pressure = struct pA | pL | pH;
	Door = struct dAI | dAO | dLI | dLO | dH;
	Robot = struct rI | rO | rT;
	State = struct sO | sC;
	Action = struct aG | aR;

map
	c2d: Chamber # Robot -> Door;
	sp: List(Pressure) # Chamber # Pressure -> List(Pressure);
	sd: List(State) # Door # State -> List(State);
	sr: List(Action) # Robot # Action -> List(Action);

var
	pressures: List(Pressure);
	pressure: Pressure;
	actions: List(Action);
	action: Action;
	states: List(State);
	state: State;

eqn
	c2d(cI, rI) = dAI;
	c2d(cI, rO) = dAI;
	c2d(cO, rI) = dAO;
	c2d(cO, rO) = dAO;
	c2d(cL, rI) = dLI;
	c2d(cL, rO) = dLO;
	c2d(cH, rI) = dH;
	c2d(cH, rO) = dH;
	
	% Dictionary for Chamber to list of Pressures
	sp(pressures, cI, pressure) = [pressure] ++ tail(pressures);
	sp(pressures, cO, pressure) = [head(pressures), pressure] ++ tail(tail(pressures));
	sp(pressures, cI, pressure) = rtail(rtail(pressures)) ++ [pressure, rhead(pressures)];
	sp(pressures, cH, pressure) = rtail(pressures) ++ [pressure];
	
	% Dictionary for Door to list of States
	sd(states, dAI, state) = [state] ++ tail(states);
	sd(states, dAO, state) = [head(states), state] ++ tail(tail(states));
	sd(states, dLI, state) = rtail(rtail(rtail(states))) ++ [state] ++ tail(tail(tail(states)));
	sd(states, dLO, state) = rtail(rtail(states)) ++ [state, rhead(states)];
	sd(states, dH,  state) = rtail(states) ++ [state];
	
	% Dictionary for Robot to list of Actions
	sr(actions, rI, action) = [action] ++ tail(actions);
	sr(actions, rO, action) = [head(actions), action, rhead(actions)];
	sr(actions, rT, action) = rtail(actions) ++ [action];
	
	
act
	tray_empty;

	% Send
	s_set_pressure: Chamber # Pressure;
	s_set_door: Door # State;
	s_move: Robot # Chamber # Action;
	s_system_want_in;
	s_system_want_out;
	s_wafer_in;
	s_wafer_out;
	s_tray_empty;
	s_pressure_confirmed: Chamber # List(Pressure);
	s_door_confirmed: Door # List(State);
	s_move_confirmed: Robot # List(State);
	
	% Receive
	r_set_pressure: Chamber # Pressure;
	r_set_door: Door # State;
	r_move: Robot # Chamber # Action;
	r_system_want_in;
	r_system_want_out;
	r_wafer_in;
	r_wafer_out;
	r_tray_empty;
	r_pressure_confirmed: Chamber # List(Pressure);
	r_door_confirmed: Door # List(State);
	r_move_confirmed: Robot # List(State);
	
	% Comm
	c_set_pressure: Chamber # Pressure;
	c_set_door: Door # State;
	c_move: Robot # Chamber # Action;
	c_system_want_in;
	c_system_want_out;
	c_wafer_in;
	c_wafer_out;
	c_tray_empty;
	c_pressure_confirmed: Chamber # List(Pressure);
	c_door_confirmed: Door # List(State);
	c_move_confirmed: Robot # List(State);

% We can try to program this anti-chronological, meaning we start with the action/process to remove a wafer, then work backwards


% We can omit the pH because the pressure in the High Vacuum Chamber is always High
proc Pressure_Controller(pressures:List(Pressure), doors:List(State)) = (
	% Confirm cI for pressures pA and pL
	r_set_pressure(cI, pA)
	. s_pressure_confirmed(cI, pressures)
	. Pressure_Controller(sp(pressures, cI, pA), doors)
	+
	r_set_pressure(cI, pL)
	. s_pressure_confirmed(cI, pressures)
	. Pressure_Controller(sp(pressures, cI, pL), doors)
	
	+
	% Confirm cO for pressures pA and pL
	r_set_pressure(cO, pA)
	. s_pressure_confirmed(cO, pressures)
	. Pressure_Controller(sp(pressures, cO, pA), doors)
	+
	r_set_pressure(cO, pL)
	. s_pressure_confirmed(cO, pressures)
	. Pressure_Controller(sp(pressures, cO, pL), doors)
	
	+
	% Confirm cL for pressures pL and pH
	r_set_pressure(cL, pL)
	. s_pressure_confirmed(cL, pressures)
	. Pressure_Controller(sp(pressures, cL, pL), doors)
	+
	r_set_pressure(cL, pH)
	. s_pressure_confirmed(cL, pressures)
	. Pressure_Controller(sp(pressures, cL, pH), doors)
	
	+
	% Confirm cH for pressure pH
	r_set_pressure(cH, pH)
	. s_pressure_confirmed(cH, pressures)
	. Pressure_Controller(sp(pressures, cH, pH), doors)
);

proc Door_Controller(states:List(State), pressures:List(Pressure)) = (











	r_set_door(dAI, sO) . s_door_confirmed(dAI, states) . Door_Controller(states, pressures)
%	s_door_confirmed(door, states) . Door_Controller(states, pressures)
%	sum a:Action. (sum r:Robot. (sum c:Chamber. (r_move(r, c, a) . Door_Controller(states, pressures))))
%	s_door_confirmed(dAO, states) . r_move(rI, cI, aR) . Door_Controller(states, pressures)
);

proc Robot_Controller(actions:List(Action), states:List(State)) = (
	% Eating wafers
	r_wafer_in
	. s_move(rT, cI, aR)
	. s_set_door(dAI, sO)
	. r_door_confirmed(dAI, states)
	. s_move_confirmed(rT, states)
	. Robot_Controller(sr(actions, rT, aR), states)
	+
	% Move wafer from input chamber to low vac chamber
	r_move(rT, cI, aR)
	. r_move_confirmed(rT, states)
	. s_move(rI, cI, aG)
	. s_set_door(dLI, sO)
	. r_door_confirmed(dLI, states)
	. s_move_confirmed(rI, states)
	. Robot_Controller(sr(actions, rI, aG), states)
	+
	% Spewing wafers
	r_move(rO, cO, aR)
	. r_move_confirmed(rO, states)
	. s_move(rT, cO, aG)
	. s_set_door(dAO, sO)
	. r_door_confirmed(dAO, states)
	. s_move_confirmed(rT, states)
	. s_wafer_out
	. Robot_Controller(sr(actions, rT, aG), states)
	
%	sum a:Action. (sum r:Robot. (sum c:Chamber. (
%		r_move(r, c, a) . 
%		(
%			(a == aG) ->
%			(
%				(c == cI) -> s_set_pressure(cI, pL) <>
%				(c == cH) -> s_set_pressure(cL, pH)
%			) <>
%			(a == aR) ->
%			(
%				(c == cH) -> s_set_pressure(cL, pH) <>
%				(c == cO) -> s_set_pressure(cO, pA)
%			)
%		) .
%		%s_open door . 
%		Robot_Controller(robots, r), states)))
	
	%Robot_Controller(robots, states)
	
	
	%s_move(rI,cI,aR) . Robot_Controller(robots, robot)
);

proc Transport_Controller(numWafersIn, numWafersOut:Int) = (
	((numWafersIn >= 1) ->
		r_move(rI, cI, aG)
%		. r_move_confirmed(rI, states)
		. s_wafer_in
		. Transport_Controller(numWafersIn - 1, numWafersOut) 
	<>
		tray_empty 
		. Transport_Controller(numWafersIn, numWafersOut)
	)
	+
	% more actions need to be added here, depending on the order of move and r_wafer_out
	% move(rT,cO,aG) ?
	(
		r_move(rT, cO, aG)
%		. r_move_confirmed(rT, states)
		. r_wafer_out 
		. Transport_Controller(numWafersIn, numWafersOut + 1)
	)
);

proc Test_Controller = (
%	r_move(rT, cI, aR)
%	. r_move_confirmed(rT, states)	
	r_move(rI, cI, aG)
	. r_set_door(dLI, sO)
	. s_move(rT, cO, aG)
%	. s_move_confirmed(rT, states)
	. s_wafer_out
	. Test_Controller
);

proc Init_Controller = (
	s_wafer_in
);

init
	allow(
		{
			tray_empty,
			
			%s_set_pressure,
			%s_set_door,
			%s_move,
			%s_wafer_in,
			%s_wafer_out,
			%s_pressure_confirmed,
			%s_door_confirmed,
			%s_move_confirmed,
			
			%r_set_pressure,
			%r_set_door,
			%r_move,
			%r_wafer_in,
			%r_wafer_out,
			%r_pressure_confirmed,
			%r_door_confirmed,
			%r_move_confirmed,
			
			c_set_pressure,
			c_set_door,
			c_move,
			c_wafer_in,
			c_wafer_out,
			c_pressure_confirmed,
			c_door_confirmed,
			c_move_confirmed
		},
		comm(
			{
				s_set_pressure | r_set_pressure -> c_set_pressure,
				s_set_door | r_set_door -> c_set_door,
				s_move | r_move -> c_move,
				s_wafer_in | r_wafer_in -> c_wafer_in,
				s_wafer_out | r_wafer_out -> c_wafer_out,
				s_pressure_confirmed | r_pressure_confirmed -> c_pressure_confirmed,
				s_door_confirmed | r_door_confirmed -> c_door_confirmed,
				s_move_confirmed | r_move_confirmed -> c_move_confirmed
				
				
				
				
				
				
				
			},
			Pressure_Controller([pA, pA, pL, pH], [sC, sC, sC, sC, sC]) ||
			Door_Controller([sC, sC, sC, sC, sC], [pA, pA, pL, pH]) ||
			Robot_Controller([aR, aR, aR], [sC, sC, sC, sC, sC]) ||
			Transport_Controller(3, 0) ||
			Test_Controller ||
			Init_Controller
		)
	);