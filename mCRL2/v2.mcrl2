sort
	Chamber = struct cT | cI | cO | cL | cH;
	Pressure = struct pA | pL | pH;
	Door = struct dAI | dAO | dLI | dLO | dH;
	Robot = struct rI | rO | rT;
	DoorState = struct sO | sC;
	Action = struct aG | aR;
	WaferStatus   = struct wN | wP;

map
	pressuresStart: Chamber -> Pressure;
	doorsStart: Door -> DoorState;
	actionsStart: Robot -> Action;

	c2d: Chamber -> List(Door); % get list of doors connected to chamber
	d2c: Door -> List(Chamber); % get list of chambers connected to door
	d2p: Door -> Pressure; % get the required pressure for all of the chambers connected to door
	cr2d: Chamber # Robot -> Door; % get the door that needs to open for a robot to perform any action in a chamber
	cs2c: Chamber # WaferStatus -> Chamber; % get the next chamber that the wafer needs to move to.
	c2c2r: Chamber # Chamber -> Robot; % get the robot that will move the wafer to the next chamber.
	c2c2a: Chamber # Chamber -> Action; % get the action for the robot that will move the wafer to the next chamber.

var
	chamber: Chamber;
	door: Door;
	robot: Robot;

eqn
	pressuresStart(chamber) = pA;
	doorsStart(door) = sC;
	actionsStart(robot) = aR;

	c2d(cI) = [dAI, dLI];
	c2d(cO) = [dAO, dLO];
	c2d(cL) = [dLI, dLO, dH];
	c2d(cH) = [dH];

	d2c(dAI) = [cI];
	d2c(dAO) = [cO];
	d2c(dLI) = [cI, cL];
	d2c(dLO) = [cL, cO];
	d2c(dH ) = [cL, cH];

	d2p(dAI) = pA;
	d2p(dAO) = pA;
	d2p(dLI) = pL;
	d2p(dLO) = pL;
	d2p(dH ) = pH;

	cr2d(cI, rI) = dAI;
	cr2d(cI, rT) = dAI;
	cr2d(cO, rO) = dAO;
	cr2d(cO, rT) = dAO;
	cr2d(cL, rI) = dLI;
	cr2d(cL, rO) = dLO;
	cr2d(cH, rI) = dH;
	cr2d(cH, rO) = dH;

	cs2c(cT, wP) = cT; % ????????
	cs2c(cT, wN) = cI;
	cs2c(cI, wP) = cT;
	cs2c(cL, wN) = cH;
	cs2c(cL, wP) = cO;
	cs2c(cH, wN) = cL; % ????????
	cs2c(cH, wP) = cL;
	cs2c(cO, wN) = cL;
	cs2c(cO, wP) = cT;

	c2c2r(cT,cI) = rT;
	c2c2r(cI,cL) = rI;
	c2c2r(cL,cH) = rI;
	c2c2r(cH,cL) = rO;
	c2c2r(cL,cO) = rO;
	c2c2r(cO,cT) = rT;

	c2c2a(cT,cI) = aR;
	c2c2a(cI,cL) = aG;
	c2c2a(cL,cH) = aR;
	c2c2a(cH,cL) = aG;
	c2c2a(cL,cO) = aR;
	c2c2a(cO,cT) = aG;

act
	nop, Yay;


	% external actions
	Wafer_In;
	Project_wafer;
	s_wafer_out;
	sysFinished;

	% communication actions (s = send, r = receive, c = communicate)
	s_Set_Door, r_Set_Door, c_Set_Door: Door # DoorState;
	s_Door_Confirmed, r_Door_Confirmed, c_Door_Confirmed: Door;

	s_Set_Pressure, r_Set_Pressure, c_Set_Pressure: Chamber # Pressure;
	s_Pressure_Confirmed, r_Pressure_Confirmed, c_Pressure_Confirmed: Chamber;

	s_Move, r_Move, c_Move: Robot # Chamber # Action;
	s_Move_Confirmed, r_Move_Confirmed, c_Move_Confirmed: Robot;

	s_door_status_request, r_door_status_request, c_door_status_request: Door;
	s_door_status_response, r_door_status_response, c_door_status_response: Door # DoorState;

	s_pressure_status_request, r_pressure_status_request, c_pressure_status_request: Chamber;
	s_pressure_status_response, r_pressure_status_response, c_pressure_status_response: Chamber # Pressure;

	s_robot_status_request, r_robot_status_request, c_robot_status_request: Robot;
	s_robot_status_response, r_robot_status_response, c_robot_status_response: Robot # Action;

	s_door_set_request, r_door_set_request, c_door_set_request: Door # DoorState;
	s_pressure_set_request, r_pressure_set_request, c_pressure_set_request: Chamber # Pressure;
	s_robot_set_request, r_robot_set_request, c_robot_set_request: Robot # Action;

proc

	Pressure_State_Controller(status: Chamber -> Pressure) = (
		sum c: Chamber, p: Pressure . r_pressure_status_request(c) . s_pressure_status_response(c, status(c)) . Pressure_State_Controller()
		+
		sum c: Chamber, p: Pressure . r_pressure_set_request(c, p) . Pressure_State_Controller(status[c -> p])
	);
	Pressure_Controller(c:Chamber) = (
	%	if p == this p -> confirm
	%	elseif doors of this room are closed -> confirm and update pressures
	%	else -> close doors, wait for confirmation of doors, send confirm and update pressures

		sum p: Pressure.
		(
			r_Set_Pressure(c, p)
			. s_pressure_status_request(c)
			. sum ps:Pressure.
			(
				r_pressure_status_response(c, ps)
				. ((p == ps) -> % if p == pstate -> confirm
					s_Pressure_Confirmed(c)
					. Pressure_Controller(c)
				<>
					sum d:Door.
					(
						((d in c2d(c)) ->
							s_Set_Door(d, sC)
							. r_Door_Confirmed(d)
						<>
							nop % Empty else statement ???
						)
					)
					. s_pressure_set_request(c, p)
					. s_Pressure_Confirmed(c)
					. Pressure_Controller(c)
				)
			)
		)
	);

	Door_State_Controller(status: Door -> DoorState) = (
		sum d: Door, s: DoorState . r_door_status_request(d) . s_door_status_response(d, status(d)) . Door_State_Controller()
		+
		sum d: Door, s: DoorState . r_door_set_request(d, s) . Door_State_Controller(status[d -> s])
	);
	Door_Controller(d:Door) = (
	%	if door is in requested state -> confirm
	%	elseif door open -> close door, confirm
	%	elseif pressure is correct -> open door, confirm
	%	else -> set pressure, wait for confirm of pressure, open door, confirm

		sum s:DoorState.
		(
			r_Set_Door(d, s)
			. s_door_status_request(d)
			. sum ds:DoorState.
			(
				r_door_status_response(d, ds)
				. ((ds == s) -> % The door is in the requested state
					s_Door_Confirmed(d)
					. Door_Controller(d)
				<> ((ds == sO) -> % The door is open and must be closed
					s_door_set_request(d, s)
					. s_Door_Confirmed(d)
					. Door_Controller(d)
					<> % The door is closed and must be opened
						sum c:Chamber.
						(
							((c in d2c(d)) ->
								s_pressure_status_request(c)
								. sum p:Pressure.
								(
									r_pressure_status_response(c, p)
									. ((d2p(d) != p) ->
										s_Set_Pressure(c, d2p(d))
										. r_Pressure_Confirmed(c)
									<>
										nop % Empty else statement ???
									)
								)
							)
						)
						. s_door_set_request(d, s)
						. s_Door_Confirmed(d)
						. Door_Controller(d)
					)
				)
			)
		)
	);

	Robot_State_Controller(status: Robot -> Action) = (
		sum r: Robot, a: Action . r_robot_status_request(r) . s_robot_status_response(r, status(r)) . Robot_State_Controller()
		+
		sum r: Robot, a: Action . r_robot_set_request(r, a) . Robot_State_Controller(status[r -> a])
	);

	Robot_Controller(r:Robot) = (
	%	if robot unoccupied ->
	%		if door open -> confirm
	%		else -> set_door open, wait for confirmation of door, confirm move
	%	else break wafer

		sum a:Action, c:Chamber.
		(
			r_Move(r, c, a)
			. s_robot_status_request(r)
			. sum as:Action.
			(
				r_robot_status_response(r, as)
				. ((as == aG) ->
					% The robot is occupied, so self loop
					s_Move(r, c, a)
					. Yay . nop
					. Robot_Controller(r)
				<>	% The robot is available
					% Open the required door for the robot
																			%sum d:Door.
																			%(
																			%	((d in cr2d(c, r)) ->
																			%		s_Set_Door(d, sO)
																			%		. r_Door_Confirmed(d)
																			%	)
																			%)
					s_Set_Door(cr2d(c, r), sO)
					. r_Door_Confirmed(cr2d(c, r))
					. ((r == rT) ->
						% The transport robot gets a command
						((c == cI && a == aR) ->
							s_Move_Confirmed(r)
							. s_Move(rI, cI, aG) % route wafer from cI to cL
							. Robot_Controller(r)
						<>
							((c == cO && a == aG) ->
								s_Move_Confirmed(r)
								. s_wafer_out % route wafer to output tray
								. Robot_Controller(r)
							)
						)
					<>
						((r == rI) ->
							% The input robot gets a command
							((c == cI && a == aG) ->
								s_Move_Confirmed(r)
								. s_Move(rI, cH, aR) % route wafer from cI to cH
								. Robot_Controller(r)
							<> ((c == cH && a == aR) ->
									s_Move_Confirmed(r)
									. s_Move(rO, cH, aG) % route wafer from cH to cO
									. Robot_Controller(r)
								<>
									nop % We could route the wafer in the opposite directions here
								)
							)
						<>
							((r == rO) ->
								% The output robot gets a command
								((c == cH && a == aG) ->
									s_Move_Confirmed(r)
									. s_Move(rO, cO, aR) % route wafer from cH to cO
									. Robot_Controller(r)
								<> ((c == cO && a == aR) ->
										s_Move_Confirmed(r)
										. s_Move(rT, cO, aG) % route wafer from cO to wafer_out
										. Robot_Controller(r)
									<>
										nop % We could route the wafer in the opposite directions here
									)
								)
							)
						)
					)
				)
			)
		)
	);

	Wafer_Controller(c:Chamber, ws: WaferStatus) = (

	%cs2c
	%c2c2r
	%c2c2a

	%nc = cs2c(c, ws)
	%a = c2c2a(c, nc)
	%r = c2c2r(c, nc)

	%s_Move(r, c, a)

		sum c:Chamber, ws: WaferStatus.
		(
			((c == cT && ws == wP) ->
				s_wafer_out
			<>
				s_Move(c2c2r(c, cs2c(c, ws)), cs2c(c, ws), c2c2a(c, cs2c(c, ws)))
				. r_Move_Confirmed(c2c2r(c, cs2c(c, ws)))
				. Wafer_Controller(c, ws)
			)
		)
	);



	Transport_Controller(numWafers: Int) = (
		((numWafers > 0) ->
			Wafer_In . (Wafer_Controller(cT, wN) || Wafer_Controller(cT, wN))
			%Wafer_In . (Transport_Controller(numWafers - 1) )%|| Wafer_Controller(cT, wN))

		<>
			sysFinished %. Transport_Controller(0)
		)
	);


init
	hide({
		s_door_status_request
	},
	allow({
		nop,
		Yay,
		c_Set_Pressure,
		c_Pressure_Confirmed,
		c_Set_Door,
		c_Door_Confirmed,
		c_Move,
		c_Move_Confirmed,
		Wafer_In,
		Project_wafer,
		s_wafer_out,
		sysFinished,


		%s_door_status_request,
		%s_door_status_response,
		%s_pressure_status_request,
		%s_pressure_status_response,
		%s_robot_status_request,
		%s_robot_status_response,
		c_door_status_request,
		c_door_status_response,
		c_pressure_status_request,
		c_pressure_status_response,
		c_robot_status_request,
		c_robot_status_response,

		c_door_set_request,
		c_pressure_set_request,
		c_robot_set_request

	},
	comm({
		s_Set_Door  				| r_Set_Door 				-> c_Set_Door,
		s_Door_Confirmed  			| r_Door_Confirmed 			-> c_Door_Confirmed,
		s_Set_Pressure  			| r_Set_Pressure 			-> c_Set_Pressure,
		s_Pressure_Confirmed  		| r_Pressure_Confirmed 		-> c_Pressure_Confirmed,
		s_Move 						| r_Move		 			-> c_Move,
		s_Move_Confirmed	  		| r_Move_Confirmed 			-> c_Move_Confirmed,
		s_door_status_request 		| r_door_status_request		-> c_door_status_request,
		s_door_status_response 		| r_door_status_response	-> c_door_status_response,
		s_pressure_status_request 	| r_pressure_status_request	-> c_pressure_status_request,
		s_pressure_status_response 	| r_pressure_status_response-> c_pressure_status_response,
		s_robot_status_request	 	| r_robot_status_request	-> c_robot_status_request,
		s_robot_status_response 	| r_robot_status_response	-> c_robot_status_response,

		s_door_set_request		 	| r_door_set_request		-> c_door_set_request,
		s_pressure_set_request		| r_pressure_set_request	-> c_pressure_set_request,
		s_robot_set_request			| r_robot_set_request		-> c_robot_set_request


	},
    Transport_Controller(5) ||
	Pressure_State_Controller(pressuresStart) ||
	Pressure_Controller(cI) ||
	Pressure_Controller(cO) ||
	Pressure_Controller(cL) ||
	Pressure_Controller(cH) ||
	Door_State_Controller(doorsStart) ||
	Door_Controller(dAI) ||
	Door_Controller(dAO) ||
	Door_Controller(dLI) ||
	Door_Controller(dLO) ||
	Door_Controller(dH ) %||
	%Robot_State_Controller(actionsStart) ||
	%Robot_Controller(rT) ||
	%Robot_Controller(rI) ||
	%Robot_Controller(rO)
	))
);
